# Learning regular expressions from plans

## Install

### Prerequisities
Following modules should be installed and available in your python environment:
- graphviz
- ordered-set

1. Clone the code with: `git clone https://redmine.ktiml.mff.cuni.cz/dck-project/dck-learning.git`
2. git checkout fsa

The main program may be tested by running:
    python learnFSA.py -h

## Usage

In order to use the program you need a directory with plans to learn from.
Let us have the directory at `PLANDIRPATH`. In this directory program expects to find plans.
Plans are text files with one action per line in the following format:

(action_name arg1 arg2 arg3 ... )

These actions are used for learning a FSA.

We can render resulting FSA diagram using `FILENAME` and `FORMAT` (only `png`,`svg` and `pdf` are supported. Textual graphviz format for further machine processing is `gv`):

    python learnFSA.py -p PLANDIRPATH -o FILENAME -f FORMAT

Resulting FSA diagram should be stored as `dck_test.cairo.cairo.png` in current directory.

If we want to merge learned FSA with existing PDDL domain, we need to specify both `DOMAINPATH` and resulting domain `FILENAME`:

    python learnFSA.py -p PLANDIRPATH -o FILENAME -m DOMAINPATH


## Implementation details

### Learning FSA (learnFSA.py)

The algorithm works recursively with sets of plans in order to build a special tree structure which is then used to build the resulting regular expression.

Input always consists of a finite set of plans. All these plans are then splitted into three sections. Every split decision is represented as a node in a tree structure.

There are following special cases for tree nodes:

1. Non trivial node represents split of all the plans using an action A_s into three sets of plans P.
e.g. one plan p = ABCACBDADABB can be split into three sets of plans called Head, Middle and Tail using the split action A_s = A:
Head(p) = {}
Middle(p) = {BC,CBD,D}
Tail(p) = BB

After spliting all plans from the input set of plans P (|P| = N), the result of the split with the action A_s is:
HeadList(A_s) = Union{ Head(P1),..., Head(PN) }
MiddleList(A_s) = Union{ Middle(P1),..., Middle(PN) }
TailList(A_s) = Union{ Tail(P1),..., Tail(PN) }

Every such node has at most three children (for each XList(A_s) such that at least one of them can be recursively processed further yielding more complex structures.

2. Trivial node is such that all siblings HeadList(A_s), MiddleList(A_s), TailList(A_s) are just sets of actions.
   This kind of node has no siblings for further processing.
   It records only information about short subplan consisting from the actions from its sibling sets and its own split action.

3. Leaf node is trivial node where all siblings are empty sets.
   This kind of node store only information about position of its split action in the tree.

### Split action selection ###

The splitting decision is made by trying all available split actions. Data from each such attempt are recorded. These are:
minAcnt .. minimal split action count found in all the plans in the input set
maxAcnt .. maximal split action count found in all the plans in the input set
totalCnt .. cummulative split action count from all the plans in the set
headList,middleList,tailList .. subplan sets generated by splitting all the plans

Subplans in [head,middle,tail]List are recorded with arguments.

In the action selection step of the algorithm the recorded data are used to compute score for each split action. This is implemented in ```selector.py```. The score computed is then used to make decision in action selection mechanism.
Action selection should always return one and only one action. Multiple levels of disambiguation can be used in order to achieve this.
On each level the ```selectTopSubset``` function is called with some scoring function. Only top scoring actions are returned in each level with the last level using lexicographic ordering as a ultimate disambiguation in case that there is still more than one action remaining.

### Pattern generation ###

### FSA merging to PDDL (FSA.py)

FSA is initialized from stack of symbols produced by ```learnFSA.py``` module.
Four kinds of items can be found on the stack:

1. action with arguments
2. set of actions
3. parenthesis
4. repetition symbols

Merging to PDDL depends on external module pyddl (reading and writing PDDL files).
Original domain PDDL file is needed. The file is read and the domain is cloned.
Then the clone actions are updated according to FSA transitions.
